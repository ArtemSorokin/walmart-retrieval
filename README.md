## Данные

Список товаров интернет-магазина (первые n страниц категорий *Laptops* и *Tablets* с сайта Walmart), где для каждого товара имеется два типа данных:
* набор пар параметр-значение;
* строка-описание, содержащая часть значений параметров.

Пример:

`{'Processor Type': 'Intel Core i3-1005G1', 'Hard Drive Capacity': '128 GB', 'Condition': 'New', 'Processor Speed': '1.2 GHz', 'Manufacturer Part Number': '7ZU89UA#ABA', 'Wireless Technology': 'Realtek RTL8821CE 802.11b/g/n/ac (1x1)(19a) Wi-Fi and Bluetooth® 4.2 Combo(MU-MIMO supported)', 'RAM Memory': '4 GB', 'Maximum RAM Supported': '4 GB', 'Operating System': 'Windows 10 Home in S mode', 'Model': '14-dq1038wm', 'Screen Size': '14"', 'Brand': 'HP'}`

`HP 14" Laptop, Intel Core i3-1005G1, 4GB SDRAM, 128GB SSD, Pale Gold, 14-DQ1038wm`

## Задача

Отранжировать товары по степени соответствия текстовому запросу.


## Принцип работы алгоритма

Ранжирование производится при помощи слегка модифицированного IDF.
На первом этапе создается инвертированный индекс, где каждому параметру соответствует словарь "значение — список товаров, у которых такой параметр имеет это значение". Индекс расширяется: значения параметров переводятся в векторное пространство, задаваемое символьно-нграммной языковой моделью, и каждому товару добавляются значения параметра, близкие по косинусному расстоянию реальному значению этого параметра для товара (скажем, если в жизни у товара был параметр "processor type" со значением "intel core i7-9750h", то он также получит значения "intel core i7", "intel core i7" и т.д.).


На втором этапе идет работа с запросом: он токенизируется (границы токенов проводятся по запятым), и для каждого токена ищутся похожие на него значения параметров в базе. Вес товара составляется как сумма весов общих значений у товара и запроса.

В итоге скор товара считается по такой формуле:
![формула](https://i.imgur.com/jVU4UTR.png)

values(product) — список значений параметров для товара, дополненный похожими значениями

$\rho(token, v)$ — косинусное расстояние между векторными представлениями токена и значения параметра

n — число товаров, для которых указан параметр

count(v) — число продуктов с таким значением параметра

## Что можно улучшить

* лучше проводить токенизацию, например пытаться заранее узнать, для какого параметра в запросе указано значение (32 GB RAM ≠ 32 GB SSD);
* очищать значения параметров (10 h == 10 hours == 10:00 h);
* использовать текстовые описания товаров, а не только их формальное задание словарем;
* оптимизировать лишние проходы по индексу и предобработку;
...

## Файловая структура проекта

    ├── data
    │   ├── index.json          <- Список продуктов с параметрами (продукт — словарь "параметр—значение")
    │   ├── index.txt           <- Список однострочных текстовых описаний продуктов
    ├── src
    │   ├── download_data.py    <- Скрипт, скачивающий данные с сайта
    │   ├── baseline_model.py   <- Модель, импортирующая Okapi BM25 и в лоб применяющая ее
    │   ├── index.py            <- Класс, который выполняет всю работу и хранит более сложную модель
    │   ├── test_model.py       <- Скрипт, использующий модель на скачанных данных
